<html lang="en"><head>
    <meta charset="UTF-8">
    <title></title>
<style  type="text/css">
        body { font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;    font-size: 18px;    line-height: 18px;    color: #737373;  
            } 
         p { margin: 9px;
            line-height: 1.7;}
            h1,h2,h3,h4,h5,h6 {  color: #88acdb; line-height: 36px;margin:10px 0;}h1 {    margin-bottom: 18px;    font-size: 30px;}h2 {    font-size: 24px;}h3 {    font-size: 18px;}h4 {    font-size: 16px;}h5 {    font-size: 14px;}h6 {    font-size: 13px;}
            hr {    margin: 0 0 19px;    border: 0;    border-bottom: 1px solid #ccc;}
           code, pre { background: #324057;
            margin: auto;
            padding: 0.35em 1.5em;
            overflow: auto;
            color: #fff;
            line-height: 1.3rem;}
            pre code {   
            font-family:Arial;
            overflow: auto;
            padding: 1px 3px;    font-size: 14px; }
            </style>
            </head><body marginheight="0"><h1>元字符</h1>
<pre><code>.    匹配除换行符以外的任意字符  
\w    匹配字母或数字或下划线或汉字 
\s    匹配任意的空白符   
\d    匹配数字  
\b    匹配单词的开始或结束  
^    匹配字符串的开始  
$    匹配字符串的结束  </code></pre>
<h1>重复的个数</h1>
<pre><code>*      重复零次或更多次
+      重复一次或更多次
?      重复零次或一次
{n}    重复n次
{n,}   重复n次或更多次
{n,m}  重复n到m次</code></pre>
<h1>字符类</h1>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。

</p>
<p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。

</p>
<h1>分支条件</h1>
<p>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开  

</p>
<h1>分组</h1>
<p>你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作

</p>
<h1>反义</h1>
<p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：
    \W    匹配任意不是字母，数字，下划线，汉字的字符
    \S    匹配任意不是空白符的字符
    \D    匹配任意非数字的字符
    \B    匹配不是单词开头或结束的位置
    [^x]    匹配除了x以外的任意字符
    [^aeiou]    匹配除了aeiou这几个字母以外的任意字符
</p>
<h1>后向引用</h1>
<p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。


</p>
<p>分组0对应整个正则表达式<br>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．
后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：

</p>
<p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。

</p>
<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：\b(?<word>\w+)\b\s+\k<word>\b。

</word></word></word></word></p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：

</p>
<p>常用分组语法





</p>
<pre><code>捕获       (exp)         匹配exp,并捕获文本到自动命名的组里
        (?&lt;name&gt;exp)     匹配exp,并捕获文本到名称为name的组里
           (?:exp)       匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言    (?=exp)      匹配exp前面的位置
            (?&lt;=exp)     匹配exp后面的位置
            (?!exp)      匹配后面跟的不是exp的位置
            (?&lt;!exp)     匹配前面不是exp的位置</code></pre>

</body></html>